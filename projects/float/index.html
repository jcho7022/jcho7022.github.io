---
layout: default
title: Business Info/Promotion App 
---
<h1>Business Info/Promotion App (<a href="https://play.google.com/store/apps/details?id=com.floatapplication">Google Play</a>)</h1>
<h2>Introduction</h2>
<p>My friend and I built Android application where users can open up shops and place a marker on the map to promote there buisiness locally. 
Users can interact with shops owners using a built in instant messaging and search up items using the search bar(supports elastic search)
  or "infinite" product scrolling. More details availiable at 
  <a href="https://play.google.com/store/apps/details?id=com.floatapplication">Google Play</a>. </p>

<h2>Backend</h2>
<h3>Introduction</h3>
<p>The backend was bulit using Node.js Docker containers following a microservice design pattern.</p>
<img src="backend_diagram.jpg" alt="server_architecture" height="600px" width="600px">

<h3>Api-gateway</h3>
<h4>Functionality</h4>
<ul class="Functionality">
				<li>Most app requests are made to the api-gateway which routes requests to the appropriate microservices</li>
				<li>Handles basic User Authentication such as check<br>
					Check jwt token expiry time and ownership for tasks that require permission</li>
				<li>Request to chat-service to generate xmpp account. <br>
          Some app requests incorporate many services and for topological simplicity services do not communicate to each other 
          Thus, the api-gateway needs track the state for requests to services. 
          For example, when a user requests for sign-up the api-gateway:
	  <br>
          1.Request to auth-service to create user
					<br>
          2.Request to user-service to create user profile
					<br>
          3.Request to chat-service to generate xmpp account
					<br>
          However, if any of these steps fail to achieve atomicity transactions must be reverted. The api-gateway a “saga state machine” to achieve such goal and maintain data consistency over distributed services. 
          For the above example if transaction #3 fails the saga state machine reverts transaction #2 and #1.
          </li>
				</ul>
   <img src="saga_state_machine.jpg" alt="saga_state_machine" height="600px" width="600px">

  <h3>Auth-service</h3>
  <h4>Functionality</h4> 
	<ul class="Functionality">
		<li>1.Stores usernames and hashed passwords using the node.js <a href="https://www.npmjs.com/package/bcrypt">Bcrypt library</a></li>
		<li>2.Sends out emails with verification codes to users upon sign-up and handles the process 
			<img src="sign_up.jpg" alt="sign_up" height="700px" width="700px"></li>
		<br>
		<li>3.Verifies oauth tokens and grants refresh token and access token 
			<img src="auth_user_session.jpg" alt="auth_user_session" height="700px" width="700px"></li>
		
	</ul>
      
   <h3>Chat-service(<a href="https://jcho7022.github.io/projects/chatbot/">Details and demo video</a>)</h3>
      <h4>Functionality</h4>
      <p>Has access to the MySQL database connected to ejabberd-service(XMPP) which allows custom http requests that
      the ejabberd framework does not support. For example, unread messages and dialogs lists cannot be synced among 
      multiple devices however adding the chat service makes such features possible. Also,
      this service handles are push notifications when users are offline.</p>
      
   <h3>Ejabberd-service(<a href="https://jcho7022.github.io/projects/chatbot/">Details and demo video</a>)</h3>
      <h4>Functionality</h4>
      <p>A xmpp framework used to add instant messaging in the app. Enabled features are:
	    <ul class="chat_features">	  
        <li><a href="https://xmpp.org/extensions/xep-0198.html">Stream Connection</a> allows detection of user disconnection for push notifications</li>
        <li><a href="https://xmpp.org/extensions/xep-0357.html">Push Notifications</a> allows messages to be sent to user when disconnected</li>
	<li><a href="https://xmpp.org/extensions/xep-0136.html">Message Archiving</a>, <a href="https://xmpp.org/extensions/xep-0280.html">Message Carbons</a> allows real time message data syncing across multiple devices</li>
	<li>TLS 1.2 encryption with a self-signed certificate(application only trusts the server)</li>	    
	</ul>
      
   <h3>User-service</h3>
    <p>Stores data of user such as profile image, shop ownership, name</p>

   <h3>Image-service</h3>
   <p>Stores image files and checks permissions of a request if image is private. Images names are stored using a MD5 hashes.</p>

   <h3>Shop-service</h3>
   <p>Stores data of shops and products in shops</p>

   <h3>Map-service</h3>
   <p>Stores data of shop markers on the map. The markers are stored and queried using mongo’s geospatial queries.</p>
     
   <h3>Continuous Integration</h3>
     Scripted a shell script which spins up containers only needed to test a service. 
     GIF OF CONTINUOUS INTEGRATION
     
   <h3>General development pipeline</h3>
	   
   <h3>*Deployment and system maintain scripts</h3>
     Shell scripts and docker-compose files  were written to to easily deploy and clean up containers
     no longer needed.
     
   <h3>Advantages felt using a Microservice design with docker</h3>
     <h4>Easy to deploy across platforms</h4>
     Basically if docker is running it is easy to deploy across any platform.
     <h4>Fast iterations</h4>
     After changing the code base we just have to rebuild one service and spin up the container.
     <h4>Fault isolation</h4>
     When designing and building this web application big effort was made such that microservices do not talk with each other encapsulating the services and making it easier to identify problems.
   
     <h3>Disadvantages felt using a Microservice design with docker</h3>
     <h4>Maintaining data consistency across services<h4>
      A huge effort needed to be made in-order to maintain a consistent data state over services. As mentioned above when adding a user a state machine was needed to revert transactions when failures occurred.

     <h4>Docker learning curve<h4>
     Long hours were spent just figuring out how to write docker, docker-compose files and handling with container network issues and framework configuration.


