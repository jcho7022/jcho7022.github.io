---
layout: default
title: Chatbot
---
<h1>Chatbot & Messaging Server/Applcation</h1>
 
<h2>Chatbot</h2>
<h3>Demo</h3>
<iframe  width="1000" height="680" src="https://www.youtube.com/embed/3hVw9_ZETow" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3>How I Built It</h3>
<p>I built the chatbot model following a <a href="https://pythonprogramming.net/chatbot-deep-learning-python-tensorflow/">Tutorial</a>. 
The model(chatbot) is based off of 170 million Reddit comments that I pre-proccessed using Python and Sqlite.
Training the model took 1 week with a GTX 1080ti. After training I put the model in a Tensorflow Docker container
 and used a python <a href="https://docs.zombofant.net/aioxmpp/devel/">XMPP library</a> to deploy it. 
When a request is made the text is inputed in the trained tensorflow model which outputs 30 suggested replies. 
A python scoring program which uses <a href="https://pypi.org/project/python-Levenshtein/">Levenshtein</a>
is used to score the outputs and returns the output with the highest score.</p> 
<h3>Client Chatbot Interaction Diagram</h3>
<img src="chatbot_client_interaction_diagram.jpg" alt="interaction diagram">
<h3>Technology Stacks Used</h3>
<p>Tensorflow, Python, XMPP, Docker</p>
<p><br><br></p>



<h2>Messaging Service</h2>
<h3>Introduction</h3>
<p>Instant messaging service that enforces real-time data consistency across multiple devices.</p>
<h3>Technology Stacks Used</h3>
<p>Back-end: Node.js, MySql, XMPP(<a href="https://www.ejabberd.im/">Ejabberd</a>), Docker<br>
Front-end: Android(Java), Sqlite, XMPP(<a href="https://github.com/igniterealtime/Smack">Smack</a>)</p>

<h3>Message Syncing Between Devices using <a href="https://xmpp.org/extensions/xep-0313.html">Message Archives</a>, HTTP</h3>
<iframe  width="1000" height="680" src="https://www.youtube.com/embed/B7QSXHUyd3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3>How I Built It</h3>
<h4>Server</h4>
<p>Using the Docker version of an XMPP framework <a href="https://www.ejabberd.im/">Ejabberd</a> I enabled the module archive messaging and 
connected it to a MySql database. Every time a message is passed in before delivering it to the recipient Ejabberd archives the message into the database.
 For archiving the dialog list I set up a trigger in the MySql database such that when a archive message is inserted the dialog list for the user is also updated.</p>
<img src="archive_message_diagram.jpg" alt="archive message diagram">
<h4>Client</h4>
<p>Built an application such that when the client app connects to the server the application can pull archive messages and cache it on the application.
When the user accesses the dialog activity the cached dialog list which is pulled earlier from the server using http is displayed. 
When the user accesses the messages activity the application queries the server for archive messages and caches the queried messaged on the app. The caching mechanism makes the messages load
faster leading to better user experience and less load on the server.</p>

<h4>Message Carbons</h4>
<iframe width="1000" height="680" src="https://www.youtube.com/embed/7ycihtTGqsM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Real time message syncing between devices logged in with the same user id. Enabled using Ejabberd for the server and the Smack libary on the application.</p>

<h3>Sending Images, User profile</h3>
<iframe  width="1000" height="680" src="https://www.youtube.com/embed/dOUVLUR15P0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h4>How I built it</h4>
<p>When sending a photo via messenger the user first uploads photos
on the server which only the sender and recipient has permission to view. Afterwards, the user sends a message that has a special tag indicating that the message 
is a photo message. When the recipient receives the message the application parses it and displays a image.</p>
<img src="image_message_diagram.jpg" alt="image_message_diagram">

<h3>Push Notifcations Using Google Firebase</h3>
<p>Due to how Android handles services the connection with the server is terminated when the application is in background.
To handle this, I integrated push notifications to notify a user that they have a message when the user is disconnected from the server. 
 However, there is a problem, how does the server know that the user is disconnected? The solution is Ejabberd offers a module called
<a href="https://xmpp.org/extensions/xep-0198.html">stream mangement</a> which allows the server to detect when the user disconnects 
. If the user is offline ejabberd requests to the chat-service to send a push notification to the recipient.</p>

<h3>Encryption</h3>
<p>Enabled using TLS 1.2 with a self-signed certificate. The application only trusts the server that I built.</p>


<h2>RESORCES</h2>
<h3>Sample java code and project structure used to implement messaging</h3>
<img src="sample_code.png" alt="chat_sample_code"  width="1280" height="900">
<h3>Chatbot source code with trained model</h3>
<h4><a href="https://drive.google.com/file/d/1sQ-DZE6il5QWxvMJ05OLRWnDe1JJdAVD/view?usp=sharing">Google Drive</a>, <a href="https://hub.docker.com/r/jcho7022/chatbot">Docker Hub</a></h4>



