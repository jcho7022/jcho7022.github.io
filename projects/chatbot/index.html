---
layout: default
title: Messaging Server/Client
---
<h1>Chatbot & Messaging Server/Client (<a href="https://gitlab.com/JarvisAPI/float">Gitlab</a>)</h1>
 
<h2>Chatbot</h2>
<h3>Demo</h3>
<iframe  width="1000" height="680" src="https://www.youtube.com/embed/3hVw9_ZETow" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3>Technology Stacks Used</h3>
<p>Tensorflow, Python, XMPP, Docker</p>
<h3>How I Built It</h3>
<p>I trained the chatbot following a <a href="https://pythonprogramming.net/chatbot-deep-learning-python-tensorflow/">Tutorial</a>. 
The model(chatbot) is based off of <a href="http://files.pushshift.io/reddit/comments/">170 million Reddit comments</a> that I pre-proccessed using Python and Sqlite.
Training the model took 1 week with a GTX 1080ti. After training it, I put the model in a Tensorflow Docker container
 and used a python <a href="https://docs.zombofant.net/aioxmpp/devel/">XMPP library</a> to connect it to the
 messaging service I built.</p> 
<h3>How It Works</h3>
<p>When a message is passed in, the text is inputed into the chatbot which outputs 30 suggested replies. 
A python script built on top of <a href="https://pypi.org/project/python-Levenshtein/">Levenshtein</a>
is used to score the outputs and returns the output with the highest score.</p> 
<img src="chatbot_client_interaction_diagram.jpg" alt="interaction diagram">
<p><br><br></p>

<h2>Messaging Service</h2>
<h3>Introduction</h3>
<p>I built an instant messaging service that enforces real-time data consistency across multiple devices. 
This project was built from scratch referencing various sources and documentation on the internet. 
 Later on I dockertized the back-end of this project and integated it to a 
 <a href="https://jcho7022.github.io/projects/float/">different project's</a> back-end.
 Also, I integrated the front-end of this project to it.
 
<h3>Technology Stacks Used</h3>
<p>Back-end: Node.js, MySql, XMPP(<a href="https://www.ejabberd.im/">Ejabberd</a>), Docker<br>
Front-end: Android(Java), Sqlite, XMPP(<a href="https://github.com/igniterealtime/Smack">Smack</a>)</p>

<h3>Message Syncing Between Devices using <a href="https://xmpp.org/extensions/xep-0313.html">Message Archives</a>, HTTP</h3>
<iframe  width="1000" height="680" src="https://www.youtube.com/embed/B7QSXHUyd3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3>How It Works</h3>
<h4>Server</h4>
<p>Using the Docker version of a XMPP framework <a href="https://www.ejabberd.im/">Ejabberd</a> I enabled the module 
 <a href="https://xmpp.org/extensions/xep-0313.html">"Message Archives"</a> and 
connected it to a MySql database. Every time a message is passed in, before delivering it to the recipient, Ejabberd archives the message into the database.
Whenever such event occurs a trigger enabled in the database updates the dialog list for the sender and recipient. 
Upon connecting to the server the client application pulls the user's dialog list and uses it to sync messages with the server.</p>
<img src="archive_message_diagram.jpg" alt="archive message diagram">
<h4>Client</h4>
<p>I built an application such that when a client connects to the server the application pulls archive messages and cache it on their device.
When a user accesses the dialog activity the cached dialog list which is pulled earlier, when the user started the application, is displayed. 
When the user accesses the message activity the application queries the server for archive messages and caches the retrieved messaged on their device.
If messages of a conversation is already stored on the device the stored messages are displayed without requesting to the server.
As a result, the load time decreases resulting in better user experience and less load on the server. When building this system I assumed that
messages are static content.</p>


<h3>Message Carbons</h3>
<iframe width="1000" height="680" src="https://www.youtube.com/embed/7ycihtTGqsM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Real time message syncing between devices logged in with the same user id. Enabled using Ejabberd's  <a href="https://xmpp.org/extensions/xep-0280.html">"Message Carbons"</a> module server and the Smack libary on the application.</p>

<h3>Sending Images, User profile</h3>
<iframe  width="1000" height="680" src="https://www.youtube.com/embed/dOUVLUR15P0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3>How It Works</h3>
<p>When sending a photo via messenger the user first uploads photos
on the server which only the sender and recipient has permission to view. Afterwards, the user sends a message that has a special tag indicating that the message 
is a photo message. When the recipient receives the message the application parses it and displays a image.</p>
<img src="image_message_diagram.jpg" alt="image_message_diagram">

<h3>Push Notifcations Using Google Firebase</h3>
<p>Due to how Android handles services the connection with the server is terminated when the application is in the background.
To handle this, I integrated push notifications to notify a user that they have a message when the user is disconnected from the server. 
 However, there is a problem, how does the server know that the user is disconnected? The solution is Ejabberd offers a module called
<a href="https://xmpp.org/extensions/xep-0198.html">stream mangement</a> which allows the server to detect when the user disconnects 
. If the recipient is offline the server makes a requests to firebase and sends a push notification.</p>

<h3>Encryption</h3>
<p>Enabled using TLS 1.2 with a self-signed certificate. The application only trusts the server.</p>

<h3>Source code with chatbot model</h3>
<h4><a href="https://drive.google.com/file/d/1sQ-DZE6il5QWxvMJ05OLRWnDe1JJdAVD/view?usp=sharing">Google Drive</a>, <a href="https://hub.docker.com/r/jcho7022/chatbot">Docker Hub</a></h4>



